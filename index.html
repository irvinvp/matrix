<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Matrix Rain</title>
  <style>
    html,body{margin:0;height:100%;background:#000;overflow:hidden}
    canvas{position:fixed;inset:0;width:100vw;height:100vh;display:block}
    /* ligero: scanlines + vignette muy baratos */
    .scan{position:fixed;inset:0;pointer-events:none;opacity:.35;
      background:repeating-linear-gradient(to bottom,rgba(0,0,0,0) 0 3px,rgba(0,0,0,.18) 4px);
      mix-blend-mode:multiply;
    }
    .vig{position:fixed;inset:0;pointer-events:none;opacity:.85;
      background:radial-gradient(ellipse at center,rgba(0,0,0,0) 0%,rgba(0,0,0,.18) 55%,rgba(0,0,0,.65) 100%);
      mix-blend-mode:multiply;
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="scan"></div>
  <div class="vig"></div>

  <script>
    (() => {
      const c = document.getElementById("c");
      const x = c.getContext("2d", { alpha: false });

      // Ajustes ligeros (sin UI)
      let fontSize = 18;
      let fade = 0.08;      // estela (alpha)
      let speedBase = 1.15; // velocidad base
      let dpr = 1, W = 0, H = 0, cols = 0;

      // Charset “Matrix-like”: katakana + dígitos + algo de latin/símbolos
      const latin = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      const digits = "0123456789";
      const symbols = "@#$%&*+=-~<>[]{}";
      const katakanaStart = 0x30A0, katakanaEnd = 0x30FF;

      const rint = (a,b)=>a+Math.floor(Math.random()*(b-a+1));
      const rand = (a,b)=>a+Math.random()*(b-a);

      function ch() {
        const p = Math.random();
        if (p < 0.75) return String.fromCharCode(rint(katakanaStart, katakanaEnd));
        if (p < 0.88) return digits[rint(0, digits.length-1)];
        if (p < 0.97) return latin[rint(0, latin.length-1)];
        return symbols[rint(0, symbols.length-1)];
      }

      // Estado por columna
      let y = [], v = [], g = [], sw = [];

      function setup() {
        dpr = Math.max(1, Math.min(2.5, devicePixelRatio || 1));
        W = innerWidth|0; H = innerHeight|0;
        c.width = (W * dpr)|0; c.height = (H * dpr)|0;
        x.setTransform(dpr, 0, 0, dpr, 0, 0);

        cols = Math.ceil(W / fontSize);
        y = new Array(cols);
        v = new Array(cols);
        g = new Array(cols);
        sw = new Array(cols);

        for (let i=0;i<cols;i++){
          // IMPORTANTE: caen de arriba hacia abajo => arrancan arriba (negativo)
          y[i] = rand(-50, 0);
          v[i] = rand(0.65, 1.7);
          sw[i] = rand(0.06, 0.22);
          g[i] = ch();
        }

        x.font = `${fontSize}px ui-monospace, Menlo, Monaco, Consolas, "Courier New", monospace`;
        x.textBaseline = "top";
      }

      let last = performance.now();
      function frame(t){
        const dt = Math.min(0.05, (t-last)/1000); last = t;

        // Fondeo con estela
        x.globalCompositeOperation = "source-over";
        x.fillStyle = `rgba(0,0,0,${fade})`;
        x.fillRect(0,0,W,H);

        // Glyphs (glow barato)
        x.globalCompositeOperation = "lighter";
        x.shadowColor = "rgba(0,255,65,.9)";
        x.shadowBlur = 10;

        const step = fontSize;

        for (let i=0;i<cols;i++){
          if (Math.random() < sw[i]) g[i] = ch();

          const px = i * step;
          const py = (y[i]|0) * step;

          // cabeza clara + cuerpo verde (simple pero efectivo)
          x.fillStyle = "rgba(210,255,220,0.92)";
          x.fillText(g[i], px, py);
          x.fillStyle = "rgba(0,255,65,0.55)";
          x.fillText(g[i], px + 0.2, py + 0.1);

          // bajar (arriba -> abajo)
          y[i] += (speedBase * v[i]) * dt * 26;

          // reset cuando sale por abajo (vuelve arriba)
          if (py > H + rand(0, H*0.35)){
            y[i] = rand(-60, -5);
            v[i] = rand(0.65, 1.7);
            sw[i] = rand(0.06, 0.22);
            g[i] = ch();
          }

          // micro “cortes” para huecos
          if (Math.random() < 0.0007) y[i] -= rand(3, 16);
        }

        x.shadowBlur = 0;
        x.globalCompositeOperation = "source-over";

        requestAnimationFrame(frame);
      }

      setup();
      addEventListener("resize", () => setup(), { passive:true });
      requestAnimationFrame(frame);
    })();
  </script>
</body>
</html>
